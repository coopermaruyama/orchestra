# Plan - 2025-08-05 07:41:26

# Revised Implementation Plan: Plancheck Extension + TimeMachine Enhancement

## Architecture Decision
**All checkpoint creation logic stays in TimeMachine**. Plancheck focuses solely on plan detection and blocking, while TimeMachine handles all git checkpointing with enhanced tag prefixes.

## Components to Create/Modify

### 1. New Extension: `src/orchestra/extensions/plancheck/`
```
plancheck/
├── __init__.py
├── plancheck_monitor.py  # Lightweight plan detection only
└── commands/
    └── __init__.py
```

**Plancheck Responsibilities (Minimal):**
- Monitor PostToolUse for ExitPlanMode tool
- Block with plancheck agent review request
- Save plans to `<state_path>/plans/<title>.md`
- **NO checkpoint creation** - signals TimeMachine instead

### 2. Enhanced TimeMachine: `src/orchestra/extensions/timemachine/timemachine_monitor.py`

**New Checkpoint Types:**
- `plan-<n>`: Created when Stop hook runs after ExitPlanMode
- `todo-<n>`: Created when TodoWrite changes detected
- `prompt-<n>`: Existing checkpoint behavior (rename from `ckpt-<n>`)

**Enhanced Hook Handlers:**
- Existing `_handle_post_tool_use_hook()`: Add TodoWrite detection
- Existing `_handle_stop_hook()`: Add plan/todo checkpoint logic
- New checkpoint type detection based on session state

### 3. Communication Between Extensions

**Session State Communication:**
```python
# Plancheck sets session state
self.update_session_state(context, {
    "plan_active": True,
    "plan_content": plan_content,
    "plan_title": extracted_title
})

# TimeMachine reads session state to determine checkpoint type
state = self.get_session_state(context)
is_plan_completion = state.get("plan_active", False)
```

### 4. Implementation Details

**Plancheck Extension (`plancheck_monitor.py`):**
```python
def _handle_post_tool_use_hook(self, context):
    tool_name = context.get("tool_name")
    
    if tool_name == "ExitPlanMode":
        # 1. Save plan to file
        self._save_plan_to_file(context)
        
        # 2. Mark plan as active in session state
        self.update_session_state(context, {"plan_active": True})
        
        # 3. Block with plancheck agent request
        return HookHandler.create_block_response(
            "ask the plancheck agent to review the current plan and decide if it needs more work"
        )
```

**Enhanced TimeMachine (`timemachine_monitor.py`):**
```python
def _handle_stop_hook(self, context):
    # Existing logic...
    
    # Determine checkpoint type based on session state
    checkpoint_type = self._determine_checkpoint_type(context)
    
    if checkpoint_type:
        checkpoint_id = self._create_typed_checkpoint(context, checkpoint_type)

def _handle_post_tool_use_hook(self, context):
    # Existing file tracking...
    
    # New: Track TodoWrite changes
    if tool_name == "TodoWrite":
        self._track_todo_changes(context)

def _determine_checkpoint_type(self, context):
    state = self.get_session_state(context)
    
    if state.get("plan_active"):
        return "plan"
    elif state.get("todos_changed"):
        return "todo"
    else:
        return "prompt"  # Default existing behavior

def _create_typed_checkpoint(self, context, checkpoint_type):
    # Enhanced checkpoint creation with typed counters
    counter = self._get_next_counter(checkpoint_type)  # plan_counter, todo_counter, prompt_counter
    checkpoint_id = f"{checkpoint_type}-{counter}"
    tag_name = f"timemachine/{checkpoint_id}"
    
    # Rest of existing checkpoint logic...
```

### 5. State Management

**Plancheck State:**
- Track plan file locations
- Monitor plan review requests

**TimeMachine State (Enhanced):**
```json
{
  "prompt_counter": 4,     // Existing (renamed from checkpoint_counter)
  "plan_counter": 2,       // New
  "todo_counter": 7,       // New
  "enabled": true
}
```

### 6. Benefits of This Architecture

**Separation of Concerns:**
- Plancheck: Plan detection and blocking only
- TimeMachine: All checkpoint creation and git operations

**Single Source of Truth:**
- All git-wip operations in TimeMachine
- Consistent checkpoint metadata format
- Unified tag management

**Extensibility:**
- Easy to add new checkpoint types
- Other extensions can signal checkpoint needs via session state
- Clean interfaces between components

## Implementation Steps

1. **Create Plancheck Extension**
   - Lightweight PostToolUse handler for ExitPlanMode
   - Plan file saving logic
   - Session state signaling to TimeMachine

2. **Enhance TimeMachine**
   - Add typed checkpoint counters
   - Enhance Stop hook with checkpoint type detection
   - Add TodoWrite change tracking
   - Update tag naming scheme

3. **Session State Communication**
   - Define state contract between extensions
   - Test state persistence across hook calls

4. **Testing & Integration**
   - Verify both extensions work independently
   - Test communication via session state
   - Validate checkpoint creation with new prefixes

This approach keeps TimeMachine as the single authority for checkpoints while allowing plancheck to focus on its core plan detection responsibility.
