[
  {
    "session_id": "7bbd38fa-26e4-414c-8898-c54a70172245",
    "transcript_path": "/Users/coopermaruyama/.claude/projects/-Users-coopermaruyama-Developer-orchestra/7bbd38fa-26e4-414c-8898-c54a70172245.jsonl",
    "cwd": "/Users/coopermaruyama/Developer/orchestra",
    "hook_event_name": "PostToolUse",
    "tool_name": "Read",
    "tool_input": {
      "file_path": "/Users/coopermaruyama/Developer/orchestra/src/orchestra/extensions/task_monitor/task_monitor.py"
    },
    "tool_response": {
      "type": "text",
      "file": {
        "filePath": "/Users/coopermaruyama/Developer/orchestra/src/orchestra/extensions/task_monitor/task_monitor.py",
        "content": "#!/usr/bin/env python3\n\"\"\"\nTask Alignment Monitor for Claude Code\nDirect integration with Claude Code hooks - no extra scripts needed\n\"\"\"\n\nimport json\nimport sys\nimport os\nfrom typing import Dict, Optional, Any, List\nfrom dataclasses import dataclass, asdict\nfrom datetime import datetime\nfrom pathlib import Path\n\n\n@dataclass\nclass TaskRequirement:\n    id: str\n    description: str\n    priority: int  # 1-5, where 1 is highest\n    completed: bool = False\n\nclass TaskAlignmentMonitor:\n    def __init__(self, config_path: Optional[str] = None) -> None:\n        # Use CLAUDE_WORKING_DIR if available, otherwise current directory\n        working_dir = os.environ.get('CLAUDE_WORKING_DIR', '.')\n        self.config_path = config_path or os.path.join(working_dir, '.claude-task.json')\n        self.task: str = \"\"\n        self.requirements: List[TaskRequirement] = []\n        self.settings: Dict[str, Any] = {}\n        self.stats: Dict[str, int] = {}\n        self.load_config()\n\n    def load_config(self) -> None:\n        \"\"\"Load or create configuration\"\"\"\n        if os.path.exists(self.config_path):\n            with open(self.config_path, 'r') as f:\n                config = json.load(f)\n                self.task = config.get('task', '')\n                self.requirements = [TaskRequirement(**req) for req in config.get('requirements', [])]\n                self.settings = config.get('settings', {})\n                self.stats = config.get('stats', {'deviations': 0, 'commands': 0})\n        else:\n            self.task = \"\"\n            self.requirements = []\n            self.settings = {\"strict_mode\": True, \"max_deviations\": 3}\n            self.stats = {'deviations': 0, 'commands': 0}\n\n    def save_config(self) -> None:\n        \"\"\"Save configuration and progress\"\"\"\n        config = {\n            'task': self.task,\n            'requirements': [asdict(req) for req in self.requirements],\n            'settings': self.settings,\n            'stats': self.stats,\n            'updated': datetime.now().isoformat()\n        }\n        with open(self.config_path, 'w') as f:\n            json.dump(config, f, indent=2)\n\n    def handle_hook(self, hook_type: str, context: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"Universal hook handler - only handles Stop hooks\"\"\"\n        if hook_type == \"Stop\":\n            return self._handle_stop_hook(context)\n        return context\n    \n    def _handle_stop_hook(self, context: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"Handle Stop hook by analyzing conversation and determining if Claude should continue\"\"\"\n        import subprocess\n        import json\n        \n        # Skip if no task configured\n        if not self.task:\n            return context\n            \n        # Avoid infinite recursion - if stop_hook_active is True, we're already processing\n        if context.get('stop_hook_active', False):\n            return context\n        \n        try:\n            # Create analysis prompt for external Claude\n            analysis_prompt = f\"\"\"\nYou are analyzing a coding session to determine if the developer has completed their stated task or if they need to continue working.\n\nCurrent Task: {self.task}\n\nRequirements Status:\n\"\"\"\n            for req in self.requirements:\n                status = \"\u2705 COMPLETED\" if req.completed else \"\u274c INCOMPLETE\"\n                analysis_prompt += f\"- {status}: {req.description} (Priority {req.priority})\\n\"\n            \n            progress = self._get_progress()\n            analysis_prompt += f\"\"\"\nCurrent Progress: {progress['percentage']:.0f}% complete ({progress['completed']}/{progress['total']} requirements)\n\nPlease analyze if the developer should continue working or if they can stop. Consider:\n1. Are all core requirements (Priority 1-2) completed?\n2. Is the main task objective achieved?\n3. Are there any critical issues that need immediate attention?\n\nUse the scope-creep-detector, over-engineering-detector, and off-topic-detector subagents to analyze if the developer is staying focused on the core task.\n\nRespond with JSON in this exact format:\n{{\n    \"should_continue\": true/false,\n    \"reason\": \"Brief explanation of why Claude should continue or can stop\",\n    \"focus_area\": \"What the developer should work on next (if continuing)\"\n}}\n\"\"\"\n            \n            # Call external Claude with the analysis prompt\n            result = subprocess.run([\n                'claude', '-p', analysis_prompt\n            ], capture_output=True, text=True, timeout=30)\n            \n            if result.returncode == 0 and result.stdout.strip():\n                try:\n                    # Parse JSON response from Claude\n                    import re\n                    json_match = re.search(r'\\{.*\\}', result.stdout, re.DOTALL)\n                    if json_match:\n                        response = json.loads(json_match.group())\n                        \n                        if response.get('should_continue', False):\n                            # Block stopping - Claude should continue\n                            reason = response.get('reason', 'Task not complete')\n                            focus_area = response.get('focus_area', '')\n                            \n                            full_reason = reason\n                            if focus_area:\n                                full_reason += f\" Focus on: {focus_area}\"\n                            \n                            return {\n                                \"decision\": \"block\",\n                                \"reason\": full_reason\n                            }\n                        else:\n                            # Allow stopping - task is complete\n                            return {\"decision\": None}\n                            \n                except json.JSONDecodeError:\n                    pass\n            \n        except Exception as e:\n            print(f\"Stop hook analysis failed: {e}\")\n        \n        # Fallback analysis based on completion status\n        incomplete_core = [r for r in self.requirements if not r.completed and r.priority <= 2]\n        if incomplete_core:\n            next_requirement = min(incomplete_core, key=lambda x: x.priority)\n            return {\n                \"decision\": \"block\", \n                \"reason\": f\"Core requirement incomplete: {next_requirement.description}\"\n            }\n        \n        # Allow stopping if no core requirements remain\n        return {\"decision\": None}\n\n\n\n    def _get_progress(self) -> Dict[str, Any]:\n        \"\"\"Calculate progress statistics\"\"\"\n        if not self.requirements:\n            return {'percentage': 0, 'completed': 0, 'total': 0}\n\n        completed = sum(1 for r in self.requirements if r.completed)\n        return {\n            'percentage': (completed / len(self.requirements)) * 100,\n            'completed': completed,\n            'total': len(self.requirements)\n        }\n\n    def _get_current_requirement(self) -> str:\n        \"\"\"Get highest priority incomplete requirement\"\"\"\n        incomplete = [r for r in self.requirements if not r.completed]\n        if incomplete:\n            next_req = min(incomplete, key=lambda x: x.priority)\n            return next_req.description\n        return \"All complete\"\n\n    def _get_next_action(self) -> str:\n        \"\"\"Suggest next action\"\"\"\n        req = self._get_current_requirement()\n        if req != \"All complete\":\n            return f\"Work on: {req}\"\n        return \"Review and finalize\"\n\ndef main() -> None:\n    \"\"\"CLI interface and hook handler\"\"\"\n    if len(sys.argv) < 2:\n        print(\"Claude Code Task Monitor\")\n        print(\"Usage: task_monitor.py <command> [args]\")\n        print(\"\\nCommands:\")\n        print(\"  start                           - Interactive task setup\")\n        print(\"  init <task> <req1> <req2> ...  - Initialize task\")\n        print(\"  status                          - Show progress\")\n        print(\"  reset                           - Reset progress\")\n        print(\"  hook <type>                     - Handle Claude Code hook\")\n        return\n\n    monitor = TaskAlignmentMonitor()\n    command = sys.argv[1]\n\n    if command == \"start\":\n        # Check if we can do interactive input\n        # In Claude Code, stdin is not a TTY, so input() will fail\n        if not sys.stdin.isatty():\n            # Non-interactive environment (like Claude Code slash command)\n            print(\"\ud83d\ude80 Claude Code Task Setup\")\n            print(\"\\n\u26a0\ufe0f  Interactive mode not available in this environment.\")\n            print(\"\\nTo set up a task, you have two options:\")\n            print(\"\\n1. Run this command directly in your terminal:\")\n            print(f\"   cd {os.getcwd()}\")\n            print(f\"   python3 {os.path.abspath(__file__)} start\")\n            print(\"\\n2. Use the quick init command with arguments:\")\n            print(\"   /task init '<task description>' '<requirement 1>' '<requirement 2>' ...\")\n            print(\"\\nExample:\")\n            print(\"   /task init 'Fix login bug' 'Reproduce the issue' 'Fix root cause' 'Add tests'\")\n            return  # Exit gracefully instead of sys.exit\n        \n        # Interactive task setup with intelligent prompting\n        print(\"\ud83d\ude80 Claude Code Task Setup\\n\")\n\n        # Task type selection\n        print(\"What type of task is this?\")\n        print(\"1. \ud83d\udc1b Bug fix\")\n        print(\"2. \u2728 New feature\")\n        print(\"3. \ud83d\udd27 Refactor\")\n        print(\"4. \ud83d\udcda Documentation\")\n        print(\"5. \ud83e\uddea Testing\")\n        print(\"6. \ud83c\udfa8 UI/UX improvement\")\n        print(\"7. \u26a1 Performance optimization\")\n        print(\"8. \ud83d\udd12 Security enhancement\")\n        print(\"9. \ud83d\udce6 Other\")\n\n        task_type_map = {\n            '1': ('bug', 'Bug Fix'),\n            '2': ('feature', 'Feature'),\n            '3': ('refactor', 'Refactor'),\n            '4': ('docs', 'Documentation'),\n            '5': ('test', 'Testing'),\n            '6': ('ui', 'UI/UX'),\n            '7': ('perf', 'Performance'),\n            '8': ('security', 'Security'),\n            '9': ('other', 'Task')\n        }\n\n        choice = input(\"\\nSelect (1-9): \").strip()\n        task_type, task_label = task_type_map.get(choice, ('other', 'Task'))\n\n        # Get initial description\n        print(f\"\\n\ud83d\udcdd Describe the {task_label.lower()}:\")\n        description = input(\"> \").strip()\n\n        # Intelligent clarification based on task type\n        clarifications = []\n\n        if task_type == 'bug':\n            print(\"\\n\ud83e\udd14 Let me help you clarify this bug fix...\")\n\n            # Error behavior\n            print(\"\\nWhat's the current incorrect behavior?\")\n            current = input(\"> \").strip()\n            if current:\n                clarifications.append(f\"Current behavior: {current}\")\n\n            # Expected behavior\n            print(\"\\nWhat should happen instead?\")\n            expected = input(\"> \").strip()\n            if expected:\n                clarifications.append(f\"Expected behavior: {expected}\")\n\n            # Scope\n            print(\"\\nAre there any edge cases or related areas that might be affected?\")\n            print(\"(Press Enter to skip)\")\n            edge_cases = input(\"> \").strip()\n            if edge_cases:\n                clarifications.append(f\"Consider: {edge_cases}\")\n\n        elif task_type == 'feature':\n            print(\"\\n\ud83e\udd14 Let's make sure we've thought this through...\")\n\n            # User value\n            print(\"\\nWho will use this feature and why?\")\n            users = input(\"> \").strip()\n            if users:\n                clarifications.append(f\"Users: {users}\")\n\n            # Success criteria\n            print(\"\\nHow will you know this feature is working correctly?\")\n            print(\"(What's the simplest test case?)\")\n            test_case = input(\"> \").strip()\n            if test_case:\n                clarifications.append(f\"Success criteria: {test_case}\")\n\n            # Non-goals\n            print(\"\\nWhat should this feature NOT do? (helps prevent scope creep)\")\n            print(\"(Press Enter to skip)\")\n            non_goals = input(\"> \").strip()\n            if non_goals:\n                clarifications.append(f\"NOT doing: {non_goals}\")\n\n            # Dependencies\n            print(\"\\nDoes this depend on any existing functionality?\")\n            print(\"(Press Enter if none)\")\n            deps = input(\"> \").strip()\n            if deps:\n                clarifications.append(f\"Depends on: {deps}\")\n\n        elif task_type == 'refactor':\n            print(\"\\n\ud83e\udd14 Let's ensure this refactor has clear goals...\")\n\n            # Problem\n            print(\"\\nWhat specific problem does this refactor solve?\")\n            problem = input(\"> \").strip()\n            if problem:\n                clarifications.append(f\"Problem: {problem}\")\n\n            # Boundaries\n            print(\"\\nWhat code should be touched? What should NOT be changed?\")\n            boundaries = input(\"> \").strip()\n            if boundaries:\n                clarifications.append(f\"Boundaries: {boundaries}\")\n\n            # Verification\n            print(\"\\nHow will you verify nothing broke? (existing tests? manual checks?)\")\n            verify = input(\"> \").strip()\n            if verify:\n                clarifications.append(f\"Verification: {verify}\")\n\n        elif task_type == 'security':\n            print(\"\\n\ud83e\udd14 Security requires careful consideration...\")\n\n            # Threat\n            print(\"\\nWhat specific vulnerability or threat are you addressing?\")\n            threat = input(\"> \").strip()\n            if threat:\n                clarifications.append(f\"Threat: {threat}\")\n\n            # Impact\n            print(\"\\nWhat could happen if this isn't fixed?\")\n            impact = input(\"> \").strip()\n            if impact:\n                clarifications.append(f\"Impact: {impact}\")\n\n        elif task_type == 'perf':\n            print(\"\\n\ud83e\udd14 Let's define performance goals...\")\n\n            # Current performance\n            print(\"\\nWhat's the current performance issue? (slow load? high memory?)\")\n            current_perf = input(\"> \").strip()\n            if current_perf:\n                clarifications.append(f\"Current issue: {current_perf}\")\n\n            # Target\n            print(\"\\nWhat's your performance target? (2x faster? under 100ms?)\")\n            target = input(\"> \").strip()\n            if target:\n                clarifications.append(f\"Target: {target}\")\n\n        # Generate smart requirements based on type and clarifications\n        requirements = []\n\n        if task_type == 'bug':\n            requirements.append(\"Reproduce the bug consistently\")\n            requirements.append(\"Fix the root cause\")\n            requirements.append(\"Add test to prevent regression\")\n            if 'edge cases' in ' '.join(clarifications).lower():\n                requirements.append(\"Handle edge cases\")\n\n        elif task_type == 'feature':\n            requirements.append(\"Implement core functionality\")\n            if test_case:\n                requirements.append(f\"Ensure {test_case}\")\n            requirements.append(\"Add error handling\")\n            requirements.append(\"Write tests\")\n            if users and 'api' not in description.lower():\n                requirements.append(\"Create user interface\")\n\n        elif task_type == 'refactor':\n            requirements.append(\"Identify code to refactor\")\n            requirements.append(\"Refactor without changing behavior\")\n            requirements.append(\"Ensure all tests pass\")\n            requirements.append(\"Update documentation if needed\")\n\n        elif task_type == 'security':\n            requirements.append(\"Identify vulnerable code\")\n            requirements.append(\"Implement secure solution\")\n            requirements.append(\"Add security tests\")\n            requirements.append(\"Document security considerations\")\n\n        elif task_type == 'perf':\n            requirements.append(\"Profile current performance\")\n            requirements.append(\"Implement optimization\")\n            requirements.append(\"Measure improvement\")\n            requirements.append(\"Ensure no functionality regression\")\n\n        else:\n            # Generic requirements\n            requirements.append(\"Implement main functionality\")\n            requirements.append(\"Handle errors gracefully\")\n            requirements.append(\"Add appropriate tests\")\n\n        # Show generated task\n        print(\"\\n\ud83d\udccb Based on our discussion, here's your task structure:\")\n        print(f\"\\nTask: [{task_label}] {description}\")\n\n        if clarifications:\n            print(\"\\nClarifications:\")\n            for c in clarifications:\n                print(f\"  \u2022 {c}\")\n\n        print(\"\\nGenerated Requirements:\")\n        for i, req in enumerate(requirements, 1):\n            print(f\"  {i}. {req}\")\n\n        # Allow requirement editing\n        print(\"\\n\u270f\ufe0f  Would you like to:\")\n        print(\"1. Use these requirements as-is\")\n        print(\"2. Add more requirements\")\n        print(\"3. Edit requirements\")\n        print(\"4. Start over\")\n\n        edit_choice = input(\"\\nSelect (1-4): \").strip()\n\n        if edit_choice == '2':\n            print(\"\\nAdd requirements (empty line to finish):\")\n            while True:\n                new_req = input(f\"{len(requirements)+1}. \").strip()\n                if not new_req:\n                    break\n                requirements.append(new_req)\n\n        elif edit_choice == '3':\n            print(\"\\nEdit requirements (enter number to edit, 'done' to finish):\")\n            while True:\n                for i, req in enumerate(requirements, 1):\n                    print(f\"  {i}. {req}\")\n                edit_num = input(\"\\nEdit which? \").strip()\n                if edit_num.lower() == 'done':\n                    break\n                try:\n                    idx = int(edit_num) - 1\n                    if 0 <= idx < len(requirements):\n                        new_text = input(f\"New text for #{edit_num}: \").strip()\n                        if new_text:\n                            requirements[idx] = new_text\n                except:\n                    pass\n\n        elif edit_choice == '4':\n            print(\"Starting over...\")\n            return main()\n\n        # Create full task description\n        full_task = f\"[{task_label}] {description}\"\n        if clarifications:\n            full_task += \" (\" + \"; \".join(clarifications) + \")\"\n\n        # Initialize with the refined task\n        print(\"\\n\ud83d\ude80 Initializing task monitor...\")\n        sys.argv = ['task_monitor.py', 'init', full_task] + requirements\n        return main()\n\n    elif command == \"init\":\n        if len(sys.argv) < 4:\n            print(\"Usage: task_monitor.py init '<task>' '<req1>' '<req2>' ...\")\n            return\n\n        monitor.task = sys.argv[2]\n        monitor.requirements = []\n\n        # Add requirements with smart priority\n        for i, desc in enumerate(sys.argv[3:], 1):\n            priority = 1 if i <= 2 else (2 if i <= 4 else 3)\n            monitor.requirements.append(\n                TaskRequirement(id=str(i), description=desc, priority=priority)\n            )\n\n        monitor.save_config()\n\n        # Create hooks configuration for Claude Code settings\n        hooks_config = {\n            \"hooks\": {\n                \"Stop\": [\n                    {\n                        \"hooks\": [\n                            {\n                                \"type\": \"command\",\n                                \"command\": f\"python {os.path.abspath(__file__)} hook Stop\"\n                            }\n                        ]\n                    }\n                ]\n            }\n        }\n\n        # Update .claude/settings.local.json with hooks\n        os.makedirs('.claude', exist_ok=True)\n        settings_file = '.claude/settings.local.json'\n        if os.path.exists(settings_file):\n            with open(settings_file, 'r') as f:\n                settings = json.load(f)\n        else:\n            settings = {}\n        \n        settings.update(hooks_config)\n        \n        with open(settings_file, 'w') as f:\n            json.dump(settings, f, indent=2)\n\n        print(f\"\u2705 Initialized: {monitor.task}\")\n        print(f\"\ud83d\udccb Requirements: {len(monitor.requirements)}\")\n        print(\"\ud83e\ude9d Hooks configured in .claude/settings.local.json\")\n        \n        # Check if .claude-task.json is in .gitignore\n        working_dir = os.environ.get('CLAUDE_WORKING_DIR', '.')\n        gitignore_path = Path(working_dir) / \".gitignore\"\n        if gitignore_path.exists():\n            with open(gitignore_path, 'r') as f:\n                gitignore_content = f.read()\n                if '.claude-task.json' not in gitignore_content:\n                    print(\"\\n\u26a0\ufe0f  Consider adding '.claude-task.json' to your .gitignore file\")\n                    print(\"   This file contains local task state and shouldn't be committed\")\n        \n        print(\"\\nRequirements:\")\n        for requirement in monitor.requirements:\n            print(f\"  - {requirement.description} (Priority {requirement.priority})\")\n\n    elif command == \"status\":\n        if not monitor.task:\n            print(\"No task configured. Run: task_monitor.py init\")\n            return\n\n        progress = monitor._get_progress()\n        print(f\"\\n\ud83d\udccc Task: {monitor.task}\")\n        print(f\"\ud83d\udcca Progress: {progress['percentage']:.0f}% complete\")\n        print(f\"\ud83d\udcc8 Stats: {monitor.stats['commands']} commands, {monitor.stats['deviations']} deviations\")\n        print(f\"\\nRequirements:\")\n\n        for requirement in monitor.requirements:\n            icon = \"\u2705\" if requirement.completed else \"\u23f3\"\n            print(f\"  {icon} {requirement.description} (P{requirement.priority})\")\n\n        if progress['percentage'] < 100:\n            print(f\"\\n\u27a1\ufe0f  Next: {monitor._get_next_action()}\")\n\n    elif command == \"reset\":\n        for requirement in monitor.requirements:\n            requirement.completed = False\n        monitor.stats = {'deviations': 0, 'commands': 0}\n        monitor.save_config()\n        print(\"\u2705 Progress reset\")\n\n    elif command == \"hook\":\n        if len(sys.argv) < 3:\n            return\n\n        hook_type = sys.argv[2]\n\n        # Read context from stdin (Claude Code passes this)\n        try:\n            context = json.loads(sys.stdin.read()) if not sys.stdin.isatty() else {}\n        except:\n            context = {}\n\n        # Handle the hook\n        result = monitor.handle_hook(hook_type, context)\n\n        # Output result for Claude Code\n        print(json.dumps(result))\n\n    elif command == \"slash-command\":\n        # Output slash command configuration for Claude Code\n        slash_config = {\n            \"commands\": {\n                \"/task\": {\n                    \"description\": \"Manage task alignment and focus\",\n                    \"subcommands\": {\n                        \"start\": {\n                            \"description\": \"Start a new task with guided setup\",\n                            \"command\": f\"python {os.path.abspath(__file__)} start\"\n                        },\n                        \"status\": {\n                            \"description\": \"Check current task progress\",\n                            \"command\": f\"python {os.path.abspath(__file__)} status\"\n                        },\n                        \"next\": {\n                            \"description\": \"Show next priority action\",\n                            \"command\": f\"python {os.path.abspath(__file__)} next\"\n                        },\n                        \"complete\": {\n                            \"description\": \"Mark current requirement as complete\",\n                            \"command\": f\"python {os.path.abspath(__file__)} complete\"\n                        },\n                        \"focus\": {\n                            \"description\": \"Get reminder of current focus area\",\n                            \"command\": f\"python {os.path.abspath(__file__)} focus\"\n                        }\n                    }\n                },\n                \"/focus\": {\n                    \"description\": \"Quick reminder of what to work on next\",\n                    \"command\": f\"python {os.path.abspath(__file__)} focus\"\n                }\n            }\n        }\n        print(json.dumps(slash_config, indent=2))\n\n    elif command == \"next\":\n        # Quick command to show next action\n        if not monitor.task:\n            print(\"No task configured. Run: /task start\")\n            return\n\n        progress = monitor._get_progress()\n        current = monitor._get_current_requirement()\n\n        if current != \"All complete\":\n            print(f\"\ud83d\udccc Next: {current}\")\n            print(f\"\ud83d\udcca Progress: {progress['percentage']:.0f}% ({progress['completed']}/{progress['total']})\")\n        else:\n            print(\"\u2705 All requirements complete!\")\n\n    elif command == \"focus\":\n        # Quick focus reminder\n        if not monitor.task:\n            print(\"No task configured. Run: /task start\")\n            return\n\n        print(f\"\ud83c\udfaf Task: {monitor.task}\")\n        print(f\"\ud83d\udccc Focus on: {monitor._get_current_requirement()}\")\n\n        # Show any active warnings\n        if monitor.stats['deviations'] > 0:\n            print(f\"\u26a0\ufe0f  {monitor.stats['deviations']} deviations detected this session\")\n\n    elif command == \"complete\":\n        # Mark current requirement as complete\n        if not monitor.task:\n            print(\"No task configured.\")\n            return\n\n        for requirement in monitor.requirements:\n            if not requirement.completed:\n                requirement.completed = True\n                monitor.save_config()\n                print(f\"\u2705 Completed: {requirement.description}\")\n\n                # Show next\n                progress = monitor._get_progress()\n                if progress['percentage'] < 100:\n                    print(f\"\\n\ud83d\udcca Progress: {progress['percentage']:.0f}% ({progress['completed']}/{progress['total']})\")\n                    print(f\"\ud83d\udccc Next: {monitor._get_current_requirement()}\")\n                else:\n                    print(\"\\n\ud83c\udf89 All requirements complete!\")\n                break\n\nif __name__ == \"__main__\":\n    main()",
        "numLines": 661,
        "startLine": 1,
        "totalLines": 661
      }
    }
  },
  {
    "session_id": "7bbd38fa-26e4-414c-8898-c54a70172245",
    "transcript_path": "/Users/coopermaruyama/.claude/projects/-Users-coopermaruyama-Developer-orchestra/7bbd38fa-26e4-414c-8898-c54a70172245.jsonl",
    "cwd": "/Users/coopermaruyama/Developer/orchestra",
    "hook_event_name": "PostToolUse",
    "tool_name": "Read",
    "tool_input": {
      "file_path": "/Users/coopermaruyama/Developer/orchestra/src/orchestra/extensions/task_monitor/task_monitor.py"
    },
    "tool_response": {
      "type": "text",
      "file": {
        "filePath": "/Users/coopermaruyama/Developer/orchestra/src/orchestra/extensions/task_monitor/task_monitor.py",
        "content": "#!/usr/bin/env python3\n\"\"\"\nTask Alignment Monitor for Claude Code\nDirect integration with Claude Code hooks - no extra scripts needed\n\"\"\"\n\nimport json\nimport sys\nimport os\nfrom typing import Dict, Optional, Any, List\nfrom dataclasses import dataclass, asdict\nfrom datetime import datetime\nfrom pathlib import Path\n\n\n@dataclass\nclass TaskRequirement:\n    id: str\n    description: str\n    priority: int  # 1-5, where 1 is highest\n    completed: bool = False\n\nclass TaskAlignmentMonitor:\n    def __init__(self, config_path: Optional[str] = None) -> None:\n        # Use CLAUDE_WORKING_DIR if available, otherwise current directory\n        working_dir = os.environ.get('CLAUDE_WORKING_DIR', '.')\n        self.config_path = config_path or os.path.join(working_dir, '.claude-task.json')\n        self.task: str = \"\"\n        self.requirements: List[TaskRequirement] = []\n        self.settings: Dict[str, Any] = {}\n        self.stats: Dict[str, int] = {}\n        self.load_config()\n\n    def load_config(self) -> None:\n        \"\"\"Load or create configuration\"\"\"\n        if os.path.exists(self.config_path):\n            with open(self.config_path, 'r') as f:\n                config = json.load(f)\n                self.task = config.get('task', '')\n                self.requirements = [TaskRequirement(**req) for req in config.get('requirements', [])]\n                self.settings = config.get('settings', {})\n                self.stats = config.get('stats', {'deviations': 0, 'commands': 0})\n        else:\n            self.task = \"\"\n            self.requirements = []\n            self.settings = {\"strict_mode\": True, \"max_deviations\": 3}\n            self.stats = {'deviations': 0, 'commands': 0}\n\n    def save_config(self) -> None:\n        \"\"\"Save configuration and progress\"\"\"\n        config = {\n            'task': self.task,\n            'requirements': [asdict(req) for req in self.requirements],\n            'settings': self.settings,\n            'stats': self.stats,\n            'updated': datetime.now().isoformat()\n        }\n        with open(self.config_path, 'w') as f:\n            json.dump(config, f, indent=2)\n\n    def handle_hook(self, hook_type: str, context: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"Universal hook handler - only handles Stop hooks\"\"\"\n        if hook_type == \"Stop\":\n            return self._handle_stop_hook(context)\n        return context\n    \n    def _handle_stop_hook(self, context: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"Handle Stop hook by analyzing conversation and determining if Claude should continue\"\"\"\n        import subprocess\n        import json\n        \n        # Skip if no task configured\n        if not self.task:\n            return context\n            \n        # Avoid infinite recursion - if stop_hook_active is True, we're already processing\n        if context.get('stop_hook_active', False):\n            return context\n        \n        try:\n            # Create analysis prompt for external Claude\n            analysis_prompt = f\"\"\"\nYou are analyzing a coding session to determine if the developer has completed their stated task or if they need to continue working.\n\nCurrent Task: {self.task}\n\nRequirements Status:\n\"\"\"\n            for req in self.requirements:\n                status = \"\u2705 COMPLETED\" if req.completed else \"\u274c INCOMPLETE\"\n                analysis_prompt += f\"- {status}: {req.description} (Priority {req.priority})\\n\"\n            \n            progress = self._get_progress()\n            analysis_prompt += f\"\"\"\nCurrent Progress: {progress['percentage']:.0f}% complete ({progress['completed']}/{progress['total']} requirements)\n\nPlease analyze if the developer should continue working or if they can stop. Consider:\n1. Are all core requirements (Priority 1-2) completed?\n2. Is the main task objective achieved?\n3. Are there any critical issues that need immediate attention?\n\nUse the scope-creep-detector, over-engineering-detector, and off-topic-detector subagents to analyze if the developer is staying focused on the core task.\n\nRespond with JSON in this exact format:\n{{\n    \"should_continue\": true/false,\n    \"reason\": \"Brief explanation of why Claude should continue or can stop\",\n    \"focus_area\": \"What the developer should work on next (if continuing)\"\n}}\n\"\"\"\n            \n            # Call external Claude with the analysis prompt\n            result = subprocess.run([\n                'claude', '-p', analysis_prompt\n            ], capture_output=True, text=True, timeout=30)\n            \n            if result.returncode == 0 and result.stdout.strip():\n                try:\n                    # Parse JSON response from Claude\n                    import re\n                    json_match = re.search(r'\\{.*\\}', result.stdout, re.DOTALL)\n                    if json_match:\n                        response = json.loads(json_match.group())\n                        \n                        if response.get('should_continue', False):\n                            # Block stopping - Claude should continue\n                            reason = response.get('reason', 'Task not complete')\n                            focus_area = response.get('focus_area', '')\n                            \n                            full_reason = reason\n                            if focus_area:\n                                full_reason += f\" Focus on: {focus_area}\"\n                            \n                            return {\n                                \"decision\": \"block\",\n                                \"reason\": full_reason\n                            }\n                        else:\n                            # Allow stopping - task is complete\n                            return {\"decision\": None}\n                            \n                except json.JSONDecodeError:\n                    pass\n            \n        except Exception as e:\n            print(f\"Stop hook analysis failed: {e}\")\n        \n        # Fallback analysis based on completion status\n        incomplete_core = [r for r in self.requirements if not r.completed and r.priority <= 2]\n        if incomplete_core:\n            next_requirement = min(incomplete_core, key=lambda x: x.priority)\n            return {\n                \"decision\": \"block\", \n                \"reason\": f\"Core requirement incomplete: {next_requirement.description}\"\n            }\n        \n        # Allow stopping if no core requirements remain\n        return {\"decision\": None}\n\n\n\n    def _get_progress(self) -> Dict[str, Any]:\n        \"\"\"Calculate progress statistics\"\"\"\n        if not self.requirements:\n            return {'percentage': 0, 'completed': 0, 'total': 0}\n\n        completed = sum(1 for r in self.requirements if r.completed)\n        return {\n            'percentage': (completed / len(self.requirements)) * 100,\n            'completed': completed,\n            'total': len(self.requirements)\n        }\n\n    def _get_current_requirement(self) -> str:\n        \"\"\"Get highest priority incomplete requirement\"\"\"\n        incomplete = [r for r in self.requirements if not r.completed]\n        if incomplete:\n            next_req = min(incomplete, key=lambda x: x.priority)\n            return next_req.description\n        return \"All complete\"\n\n    def _get_next_action(self) -> str:\n        \"\"\"Suggest next action\"\"\"\n        req = self._get_current_requirement()\n        if req != \"All complete\":\n            return f\"Work on: {req}\"\n        return \"Review and finalize\"\n\ndef main() -> None:\n    \"\"\"CLI interface and hook handler\"\"\"\n    if len(sys.argv) < 2:\n        print(\"Claude Code Task Monitor\")\n        print(\"Usage: task_monitor.py <command> [args]\")\n        print(\"\\nCommands:\")\n        print(\"  start                           - Interactive task setup\")\n        print(\"  init <task> <req1> <req2> ...  - Initialize task\")\n        print(\"  status                          - Show progress\")\n        print(\"  reset                           - Reset progress\")\n        print(\"  hook <type>                     - Handle Claude Code hook\")\n        return\n\n    monitor = TaskAlignmentMonitor()\n    command = sys.argv[1]\n\n    if command == \"start\":\n        # Check if we can do interactive input\n        # In Claude Code, stdin is not a TTY, so input() will fail\n        if not sys.stdin.isatty():\n            # Non-interactive environment (like Claude Code slash command)\n            print(\"\ud83d\ude80 Claude Code Task Setup\")\n            print(\"\\n\u26a0\ufe0f  Interactive mode not available in this environment.\")\n            print(\"\\nTo set up a task, you have two options:\")\n            print(\"\\n1. Run this command directly in your terminal:\")\n            print(f\"   cd {os.getcwd()}\")\n            print(f\"   python3 {os.path.abspath(__file__)} start\")\n            print(\"\\n2. Use the quick init command with arguments:\")\n            print(\"   /task init '<task description>' '<requirement 1>' '<requirement 2>' ...\")\n            print(\"\\nExample:\")\n            print(\"   /task init 'Fix login bug' 'Reproduce the issue' 'Fix root cause' 'Add tests'\")\n            return  # Exit gracefully instead of sys.exit\n        \n        # Interactive task setup with intelligent prompting\n        print(\"\ud83d\ude80 Claude Code Task Setup\\n\")\n\n        # Task type selection\n        print(\"What type of task is this?\")\n        print(\"1. \ud83d\udc1b Bug fix\")\n        print(\"2. \u2728 New feature\")\n        print(\"3. \ud83d\udd27 Refactor\")\n        print(\"4. \ud83d\udcda Documentation\")\n        print(\"5. \ud83e\uddea Testing\")\n        print(\"6. \ud83c\udfa8 UI/UX improvement\")\n        print(\"7. \u26a1 Performance optimization\")\n        print(\"8. \ud83d\udd12 Security enhancement\")\n        print(\"9. \ud83d\udce6 Other\")\n\n        task_type_map = {\n            '1': ('bug', 'Bug Fix'),\n            '2': ('feature', 'Feature'),\n            '3': ('refactor', 'Refactor'),\n            '4': ('docs', 'Documentation'),\n            '5': ('test', 'Testing'),\n            '6': ('ui', 'UI/UX'),\n            '7': ('perf', 'Performance'),\n            '8': ('security', 'Security'),\n            '9': ('other', 'Task')\n        }\n\n        choice = input(\"\\nSelect (1-9): \").strip()\n        task_type, task_label = task_type_map.get(choice, ('other', 'Task'))\n\n        # Get initial description\n        print(f\"\\n\ud83d\udcdd Describe the {task_label.lower()}:\")\n        description = input(\"> \").strip()\n\n        # Intelligent clarification based on task type\n        clarifications = []\n\n        if task_type == 'bug':\n            print(\"\\n\ud83e\udd14 Let me help you clarify this bug fix...\")\n\n            # Error behavior\n            print(\"\\nWhat's the current incorrect behavior?\")\n            current = input(\"> \").strip()\n            if current:\n                clarifications.append(f\"Current behavior: {current}\")\n\n            # Expected behavior\n            print(\"\\nWhat should happen instead?\")\n            expected = input(\"> \").strip()\n            if expected:\n                clarifications.append(f\"Expected behavior: {expected}\")\n\n            # Scope\n            print(\"\\nAre there any edge cases or related areas that might be affected?\")\n            print(\"(Press Enter to skip)\")\n            edge_cases = input(\"> \").strip()\n            if edge_cases:\n                clarifications.append(f\"Consider: {edge_cases}\")\n\n        elif task_type == 'feature':\n            print(\"\\n\ud83e\udd14 Let's make sure we've thought this through...\")\n\n            # User value\n            print(\"\\nWho will use this feature and why?\")\n            users = input(\"> \").strip()\n            if users:\n                clarifications.append(f\"Users: {users}\")\n\n            # Success criteria\n            print(\"\\nHow will you know this feature is working correctly?\")\n            print(\"(What's the simplest test case?)\")\n            test_case = input(\"> \").strip()\n            if test_case:\n                clarifications.append(f\"Success criteria: {test_case}\")\n\n            # Non-goals\n            print(\"\\nWhat should this feature NOT do? (helps prevent scope creep)\")\n            print(\"(Press Enter to skip)\")\n            non_goals = input(\"> \").strip()\n            if non_goals:\n                clarifications.append(f\"NOT doing: {non_goals}\")\n\n            # Dependencies\n            print(\"\\nDoes this depend on any existing functionality?\")\n            print(\"(Press Enter if none)\")\n            deps = input(\"> \").strip()\n            if deps:\n                clarifications.append(f\"Depends on: {deps}\")\n\n        elif task_type == 'refactor':\n            print(\"\\n\ud83e\udd14 Let's ensure this refactor has clear goals...\")\n\n            # Problem\n            print(\"\\nWhat specific problem does this refactor solve?\")\n            problem = input(\"> \").strip()\n            if problem:\n                clarifications.append(f\"Problem: {problem}\")\n\n            # Boundaries\n            print(\"\\nWhat code should be touched? What should NOT be changed?\")\n            boundaries = input(\"> \").strip()\n            if boundaries:\n                clarifications.append(f\"Boundaries: {boundaries}\")\n\n            # Verification\n            print(\"\\nHow will you verify nothing broke? (existing tests? manual checks?)\")\n            verify = input(\"> \").strip()\n            if verify:\n                clarifications.append(f\"Verification: {verify}\")\n\n        elif task_type == 'security':\n            print(\"\\n\ud83e\udd14 Security requires careful consideration...\")\n\n            # Threat\n            print(\"\\nWhat specific vulnerability or threat are you addressing?\")\n            threat = input(\"> \").strip()\n            if threat:\n                clarifications.append(f\"Threat: {threat}\")\n\n            # Impact\n            print(\"\\nWhat could happen if this isn't fixed?\")\n            impact = input(\"> \").strip()\n            if impact:\n                clarifications.append(f\"Impact: {impact}\")\n\n        elif task_type == 'perf':\n            print(\"\\n\ud83e\udd14 Let's define performance goals...\")\n\n            # Current performance\n            print(\"\\nWhat's the current performance issue? (slow load? high memory?)\")\n            current_perf = input(\"> \").strip()\n            if current_perf:\n                clarifications.append(f\"Current issue: {current_perf}\")\n\n            # Target\n            print(\"\\nWhat's your performance target? (2x faster? under 100ms?)\")\n            target = input(\"> \").strip()\n            if target:\n                clarifications.append(f\"Target: {target}\")\n\n        # Generate smart requirements based on type and clarifications\n        requirements = []\n\n        if task_type == 'bug':\n            requirements.append(\"Reproduce the bug consistently\")\n            requirements.append(\"Fix the root cause\")\n            requirements.append(\"Add test to prevent regression\")\n            if 'edge cases' in ' '.join(clarifications).lower():\n                requirements.append(\"Handle edge cases\")\n\n        elif task_type == 'feature':\n            requirements.append(\"Implement core functionality\")\n            if test_case:\n                requirements.append(f\"Ensure {test_case}\")\n            requirements.append(\"Add error handling\")\n            requirements.append(\"Write tests\")\n            if users and 'api' not in description.lower():\n                requirements.append(\"Create user interface\")\n\n        elif task_type == 'refactor':\n            requirements.append(\"Identify code to refactor\")\n            requirements.append(\"Refactor without changing behavior\")\n            requirements.append(\"Ensure all tests pass\")\n            requirements.append(\"Update documentation if needed\")\n\n        elif task_type == 'security':\n            requirements.append(\"Identify vulnerable code\")\n            requirements.append(\"Implement secure solution\")\n            requirements.append(\"Add security tests\")\n            requirements.append(\"Document security considerations\")\n\n        elif task_type == 'perf':\n            requirements.append(\"Profile current performance\")\n            requirements.append(\"Implement optimization\")\n            requirements.append(\"Measure improvement\")\n            requirements.append(\"Ensure no functionality regression\")\n\n        else:\n            # Generic requirements\n            requirements.append(\"Implement main functionality\")\n            requirements.append(\"Handle errors gracefully\")\n            requirements.append(\"Add appropriate tests\")\n\n        # Show generated task\n        print(\"\\n\ud83d\udccb Based on our discussion, here's your task structure:\")\n        print(f\"\\nTask: [{task_label}] {description}\")\n\n        if clarifications:\n            print(\"\\nClarifications:\")\n            for c in clarifications:\n                print(f\"  \u2022 {c}\")\n\n        print(\"\\nGenerated Requirements:\")\n        for i, req in enumerate(requirements, 1):\n            print(f\"  {i}. {req}\")\n\n        # Allow requirement editing\n        print(\"\\n\u270f\ufe0f  Would you like to:\")\n        print(\"1. Use these requirements as-is\")\n        print(\"2. Add more requirements\")\n        print(\"3. Edit requirements\")\n        print(\"4. Start over\")\n\n        edit_choice = input(\"\\nSelect (1-4): \").strip()\n\n        if edit_choice == '2':\n            print(\"\\nAdd requirements (empty line to finish):\")\n            while True:\n                new_req = input(f\"{len(requirements)+1}. \").strip()\n                if not new_req:\n                    break\n                requirements.append(new_req)\n\n        elif edit_choice == '3':\n            print(\"\\nEdit requirements (enter number to edit, 'done' to finish):\")\n            while True:\n                for i, req in enumerate(requirements, 1):\n                    print(f\"  {i}. {req}\")\n                edit_num = input(\"\\nEdit which? \").strip()\n                if edit_num.lower() == 'done':\n                    break\n                try:\n                    idx = int(edit_num) - 1\n                    if 0 <= idx < len(requirements):\n                        new_text = input(f\"New text for #{edit_num}: \").strip()\n                        if new_text:\n                            requirements[idx] = new_text\n                except:\n                    pass\n\n        elif edit_choice == '4':\n            print(\"Starting over...\")\n            return main()\n\n        # Create full task description\n        full_task = f\"[{task_label}] {description}\"\n        if clarifications:\n            full_task += \" (\" + \"; \".join(clarifications) + \")\"\n\n        # Initialize with the refined task\n        print(\"\\n\ud83d\ude80 Initializing task monitor...\")\n        sys.argv = ['task_monitor.py', 'init', full_task] + requirements\n        return main()\n\n    elif command == \"init\":\n        if len(sys.argv) < 4:\n            print(\"Usage: task_monitor.py init '<task>' '<req1>' '<req2>' ...\")\n            return\n\n        monitor.task = sys.argv[2]\n        monitor.requirements = []\n\n        # Add requirements with smart priority\n        for i, desc in enumerate(sys.argv[3:], 1):\n            priority = 1 if i <= 2 else (2 if i <= 4 else 3)\n            monitor.requirements.append(\n                TaskRequirement(id=str(i), description=desc, priority=priority)\n            )\n\n        monitor.save_config()\n\n        # Create hooks configuration for Claude Code settings\n        hooks_config = {\n            \"hooks\": {\n                \"Stop\": [\n                    {\n                        \"hooks\": [\n                            {\n                                \"type\": \"command\",\n                                \"command\": f\"python {os.path.abspath(__file__)} hook Stop\"\n                            }\n                        ]\n                    }\n                ]\n            }\n        }\n\n        # Update .claude/settings.local.json with hooks\n        os.makedirs('.claude', exist_ok=True)\n        settings_file = '.claude/settings.local.json'\n        if os.path.exists(settings_file):\n            with open(settings_file, 'r') as f:\n                settings = json.load(f)\n        else:\n            settings = {}\n        \n        settings.update(hooks_config)\n        \n        with open(settings_file, 'w') as f:\n            json.dump(settings, f, indent=2)\n\n        print(f\"\u2705 Initialized: {monitor.task}\")\n        print(f\"\ud83d\udccb Requirements: {len(monitor.requirements)}\")\n        print(\"\ud83e\ude9d Hooks configured in .claude/settings.local.json\")\n        \n        # Check if .claude-task.json is in .gitignore\n        working_dir = os.environ.get('CLAUDE_WORKING_DIR', '.')\n        gitignore_path = Path(working_dir) / \".gitignore\"\n        if gitignore_path.exists():\n            with open(gitignore_path, 'r') as f:\n                gitignore_content = f.read()\n                if '.claude-task.json' not in gitignore_content:\n                    print(\"\\n\u26a0\ufe0f  Consider adding '.claude-task.json' to your .gitignore file\")\n                    print(\"   This file contains local task state and shouldn't be committed\")\n        \n        print(\"\\nRequirements:\")\n        for requirement in monitor.requirements:\n            print(f\"  - {requirement.description} (Priority {requirement.priority})\")\n\n    elif command == \"status\":\n        if not monitor.task:\n            print(\"No task configured. Run: task_monitor.py init\")\n            return\n\n        progress = monitor._get_progress()\n        print(f\"\\n\ud83d\udccc Task: {monitor.task}\")\n        print(f\"\ud83d\udcca Progress: {progress['percentage']:.0f}% complete\")\n        print(f\"\ud83d\udcc8 Stats: {monitor.stats['commands']} commands, {monitor.stats['deviations']} deviations\")\n        print(f\"\\nRequirements:\")\n\n        for requirement in monitor.requirements:\n            icon = \"\u2705\" if requirement.completed else \"\u23f3\"\n            print(f\"  {icon} {requirement.description} (P{requirement.priority})\")\n\n        if progress['percentage'] < 100:\n            print(f\"\\n\u27a1\ufe0f  Next: {monitor._get_next_action()}\")\n\n    elif command == \"reset\":\n        for requirement in monitor.requirements:\n            requirement.completed = False\n        monitor.stats = {'deviations': 0, 'commands': 0}\n        monitor.save_config()\n        print(\"\u2705 Progress reset\")\n\n    elif command == \"hook\":\n        if len(sys.argv) < 3:\n            return\n\n        hook_type = sys.argv[2]\n\n        # Read context from stdin (Claude Code passes this)\n        try:\n            context = json.loads(sys.stdin.read()) if not sys.stdin.isatty() else {}\n        except:\n            context = {}\n\n        # Handle the hook\n        result = monitor.handle_hook(hook_type, context)\n\n        # Output result for Claude Code\n        print(json.dumps(result))\n\n    elif command == \"slash-command\":\n        # Output slash command configuration for Claude Code\n        slash_config = {\n            \"commands\": {\n                \"/task\": {\n                    \"description\": \"Manage task alignment and focus\",\n                    \"subcommands\": {\n                        \"start\": {\n                            \"description\": \"Start a new task with guided setup\",\n                            \"command\": f\"python {os.path.abspath(__file__)} start\"\n                        },\n                        \"status\": {\n                            \"description\": \"Check current task progress\",\n                            \"command\": f\"python {os.path.abspath(__file__)} status\"\n                        },\n                        \"next\": {\n                            \"description\": \"Show next priority action\",\n                            \"command\": f\"python {os.path.abspath(__file__)} next\"\n                        },\n                        \"complete\": {\n                            \"description\": \"Mark current requirement as complete\",\n                            \"command\": f\"python {os.path.abspath(__file__)} complete\"\n                        },\n                        \"focus\": {\n                            \"description\": \"Get reminder of current focus area\",\n                            \"command\": f\"python {os.path.abspath(__file__)} focus\"\n                        }\n                    }\n                },\n                \"/focus\": {\n                    \"description\": \"Quick reminder of what to work on next\",\n                    \"command\": f\"python {os.path.abspath(__file__)} focus\"\n                }\n            }\n        }\n        print(json.dumps(slash_config, indent=2))\n\n    elif command == \"next\":\n        # Quick command to show next action\n        if not monitor.task:\n            print(\"No task configured. Run: /task start\")\n            return\n\n        progress = monitor._get_progress()\n        current = monitor._get_current_requirement()\n\n        if current != \"All complete\":\n            print(f\"\ud83d\udccc Next: {current}\")\n            print(f\"\ud83d\udcca Progress: {progress['percentage']:.0f}% ({progress['completed']}/{progress['total']})\")\n        else:\n            print(\"\u2705 All requirements complete!\")\n\n    elif command == \"focus\":\n        # Quick focus reminder\n        if not monitor.task:\n            print(\"No task configured. Run: /task start\")\n            return\n\n        print(f\"\ud83c\udfaf Task: {monitor.task}\")\n        print(f\"\ud83d\udccc Focus on: {monitor._get_current_requirement()}\")\n\n        # Show any active warnings\n        if monitor.stats['deviations'] > 0:\n            print(f\"\u26a0\ufe0f  {monitor.stats['deviations']} deviations detected this session\")\n\n    elif command == \"complete\":\n        # Mark current requirement as complete\n        if not monitor.task:\n            print(\"No task configured.\")\n            return\n\n        for requirement in monitor.requirements:\n            if not requirement.completed:\n                requirement.completed = True\n                monitor.save_config()\n                print(f\"\u2705 Completed: {requirement.description}\")\n\n                # Show next\n                progress = monitor._get_progress()\n                if progress['percentage'] < 100:\n                    print(f\"\\n\ud83d\udcca Progress: {progress['percentage']:.0f}% ({progress['completed']}/{progress['total']})\")\n                    print(f\"\ud83d\udccc Next: {monitor._get_current_requirement()}\")\n                else:\n                    print(\"\\n\ud83c\udf89 All requirements complete!\")\n                break\n\nif __name__ == \"__main__\":\n    main()",
        "numLines": 661,
        "startLine": 1,
        "totalLines": 661
      }
    }
  },
  {
    "session_id": "7bbd38fa-26e4-414c-8898-c54a70172245",
    "transcript_path": "/Users/coopermaruyama/.claude/projects/-Users-coopermaruyama-Developer-orchestra/7bbd38fa-26e4-414c-8898-c54a70172245.jsonl",
    "cwd": "/Users/coopermaruyama/Developer/orchestra",
    "hook_event_name": "PostToolUse",
    "tool_name": "Glob",
    "tool_input": {
      "pattern": "**/task_monitor.py"
    },
    "tool_response": {
      "filenames": [
        "/Users/coopermaruyama/Developer/orchestra/build/lib/extensions/task-monitor/task_monitor.py",
        "/Users/coopermaruyama/Developer/orchestra/build/lib/orchestra/extensions/task-monitor/task_monitor.py",
        "/Users/coopermaruyama/Developer/orchestra/src/orchestra/extensions/task_monitor/task_monitor.py"
      ],
      "durationMs": 6,
      "numFiles": 3,
      "truncated": false
    }
  },
  {
    "session_id": "7bbd38fa-26e4-414c-8898-c54a70172245",
    "transcript_path": "/Users/coopermaruyama/.claude/projects/-Users-coopermaruyama-Developer-orchestra/7bbd38fa-26e4-414c-8898-c54a70172245.jsonl",
    "cwd": "/Users/coopermaruyama/Developer/orchestra",
    "hook_event_name": "PostToolUse",
    "tool_name": "Read",
    "tool_input": {
      "file_path": "/Users/coopermaruyama/Developer/orchestra/src/orchestra/extensions/task_monitor/task_monitor.py"
    },
    "tool_response": {
      "type": "text",
      "file": {
        "filePath": "/Users/coopermaruyama/Developer/orchestra/src/orchestra/extensions/task_monitor/task_monitor.py",
        "content": "#!/usr/bin/env python3\n\"\"\"\nTask Alignment Monitor for Claude Code\nDirect integration with Claude Code hooks - no extra scripts needed\n\"\"\"\n\nimport json\nimport sys\nimport os\nfrom typing import Dict, Optional, Any, List\nfrom dataclasses import dataclass, asdict\nfrom datetime import datetime\nfrom pathlib import Path\n\n\n@dataclass\nclass TaskRequirement:\n    id: str\n    description: str\n    priority: int  # 1-5, where 1 is highest\n    completed: bool = False\n\nclass TaskAlignmentMonitor:\n    def __init__(self, config_path: Optional[str] = None) -> None:\n        # Use CLAUDE_WORKING_DIR if available, otherwise current directory\n        working_dir = os.environ.get('CLAUDE_WORKING_DIR', '.')\n        self.config_path = config_path or os.path.join(working_dir, '.claude-task.json')\n        self.task: str = \"\"\n        self.requirements: List[TaskRequirement] = []\n        self.settings: Dict[str, Any] = {}\n        self.stats: Dict[str, int] = {}\n        self.load_config()\n\n    def load_config(self) -> None:\n        \"\"\"Load or create configuration\"\"\"\n        if os.path.exists(self.config_path):\n            with open(self.config_path, 'r') as f:\n                config = json.load(f)\n                self.task = config.get('task', '')\n                self.requirements = [TaskRequirement(**req) for req in config.get('requirements', [])]\n                self.settings = config.get('settings', {})\n                self.stats = config.get('stats', {'deviations': 0, 'commands': 0})\n        else:\n            self.task = \"\"\n            self.requirements = []\n            self.settings = {\"strict_mode\": True, \"max_deviations\": 3}\n            self.stats = {'deviations': 0, 'commands': 0}\n\n    def save_config(self) -> None:\n        \"\"\"Save configuration and progress\"\"\"\n        config = {\n            'task': self.task,\n            'requirements': [asdict(req) for req in self.requirements],\n            'settings': self.settings,\n            'stats': self.stats,\n            'updated': datetime.now().isoformat()\n        }\n        with open(self.config_path, 'w') as f:\n            json.dump(config, f, indent=2)\n\n    def handle_hook(self, hook_type: str, context: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"Universal hook handler - only handles Stop hooks\"\"\"\n        if hook_type == \"Stop\":\n            return self._handle_stop_hook(context)\n        return context\n    \n    def _handle_stop_hook(self, context: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"Handle Stop hook by analyzing conversation and determining if Claude should continue\"\"\"\n        import subprocess\n        import json\n        \n        # Skip if no task configured\n        if not self.task:\n            return context\n            \n        # Avoid infinite recursion - if stop_hook_active is True, we're already processing\n        if context.get('stop_hook_active', False):\n            return context\n        \n        try:\n            # Create analysis prompt for external Claude\n            analysis_prompt = f\"\"\"\nYou are analyzing a coding session to determine if the developer has completed their stated task or if they need to continue working.\n\nCurrent Task: {self.task}\n\nRequirements Status:\n\"\"\"\n            for req in self.requirements:\n                status = \"\u2705 COMPLETED\" if req.completed else \"\u274c INCOMPLETE\"\n                analysis_prompt += f\"- {status}: {req.description} (Priority {req.priority})\\n\"\n            \n            progress = self._get_progress()\n            analysis_prompt += f\"\"\"\nCurrent Progress: {progress['percentage']:.0f}% complete ({progress['completed']}/{progress['total']} requirements)\n\nPlease analyze if the developer should continue working or if they can stop. Consider:\n1. Are all core requirements (Priority 1-2) completed?\n2. Is the main task objective achieved?\n3. Are there any critical issues that need immediate attention?\n\nUse the scope-creep-detector, over-engineering-detector, and off-topic-detector subagents to analyze if the developer is staying focused on the core task.\n\nRespond with JSON in this exact format:\n{{\n    \"should_continue\": true/false,\n    \"reason\": \"Brief explanation of why Claude should continue or can stop\",\n    \"focus_area\": \"What the developer should work on next (if continuing)\"\n}}\n\"\"\"\n            \n            # Call external Claude with the analysis prompt\n            result = subprocess.run([\n                'claude', '-p', analysis_prompt\n            ], capture_output=True, text=True, timeout=30)\n            \n            if result.returncode == 0 and result.stdout.strip():\n                try:\n                    # Parse JSON response from Claude\n                    import re\n                    json_match = re.search(r'\\{.*\\}', result.stdout, re.DOTALL)\n                    if json_match:\n                        response = json.loads(json_match.group())\n                        \n                        if response.get('should_continue', False):\n                            # Block stopping - Claude should continue\n                            reason = response.get('reason', 'Task not complete')\n                            focus_area = response.get('focus_area', '')\n                            \n                            full_reason = reason\n                            if focus_area:\n                                full_reason += f\" Focus on: {focus_area}\"\n                            \n                            return {\n                                \"decision\": \"block\",\n                                \"reason\": full_reason\n                            }\n                        else:\n                            # Allow stopping - task is complete\n                            return {\"decision\": None}\n                            \n                except json.JSONDecodeError:\n                    pass\n            \n        except Exception as e:\n            print(f\"Stop hook analysis failed: {e}\")\n        \n        # Fallback analysis based on completion status\n        incomplete_core = [r for r in self.requirements if not r.completed and r.priority <= 2]\n        if incomplete_core:\n            next_requirement = min(incomplete_core, key=lambda x: x.priority)\n            return {\n                \"decision\": \"block\", \n                \"reason\": f\"Core requirement incomplete: {next_requirement.description}\"\n            }\n        \n        # Allow stopping if no core requirements remain\n        return {\"decision\": None}\n\n\n\n    def _get_progress(self) -> Dict[str, Any]:\n        \"\"\"Calculate progress statistics\"\"\"\n        if not self.requirements:\n            return {'percentage': 0, 'completed': 0, 'total': 0}\n\n        completed = sum(1 for r in self.requirements if r.completed)\n        return {\n            'percentage': (completed / len(self.requirements)) * 100,\n            'completed': completed,\n            'total': len(self.requirements)\n        }\n\n    def _get_current_requirement(self) -> str:\n        \"\"\"Get highest priority incomplete requirement\"\"\"\n        incomplete = [r for r in self.requirements if not r.completed]\n        if incomplete:\n            next_req = min(incomplete, key=lambda x: x.priority)\n            return next_req.description\n        return \"All complete\"\n\n    def _get_next_action(self) -> str:\n        \"\"\"Suggest next action\"\"\"\n        req = self._get_current_requirement()\n        if req != \"All complete\":\n            return f\"Work on: {req}\"\n        return \"Review and finalize\"\n\ndef main() -> None:\n    \"\"\"CLI interface and hook handler\"\"\"\n    if len(sys.argv) < 2:\n        print(\"Claude Code Task Monitor\")\n        print(\"Usage: task_monitor.py <command> [args]\")\n        print(\"\\nCommands:\")\n        print(\"  start                           - Interactive task setup\")\n        print(\"  init <task> <req1> <req2> ...  - Initialize task\")\n        print(\"  status                          - Show progress\")\n        print(\"  reset                           - Reset progress\")\n        print(\"  hook <type>                     - Handle Claude Code hook\")\n        return\n\n    monitor = TaskAlignmentMonitor()\n    command = sys.argv[1]\n\n    if command == \"start\":\n        # Check if we can do interactive input\n        # In Claude Code, stdin is not a TTY, so input() will fail\n        if not sys.stdin.isatty():\n            # Non-interactive environment (like Claude Code slash command)\n            print(\"\ud83d\ude80 Claude Code Task Setup\")\n            print(\"\\n\u26a0\ufe0f  Interactive mode not available in this environment.\")\n            print(\"\\nTo set up a task, you have two options:\")\n            print(\"\\n1. Run this command directly in your terminal:\")\n            print(f\"   cd {os.getcwd()}\")\n            print(f\"   python3 {os.path.abspath(__file__)} start\")\n            print(\"\\n2. Use the quick init command with arguments:\")\n            print(\"   /task init '<task description>' '<requirement 1>' '<requirement 2>' ...\")\n            print(\"\\nExample:\")\n            print(\"   /task init 'Fix login bug' 'Reproduce the issue' 'Fix root cause' 'Add tests'\")\n            return  # Exit gracefully instead of sys.exit\n        \n        # Interactive task setup with intelligent prompting\n        print(\"\ud83d\ude80 Claude Code Task Setup\\n\")\n\n        # Task type selection\n        print(\"What type of task is this?\")\n        print(\"1. \ud83d\udc1b Bug fix\")\n        print(\"2. \u2728 New feature\")\n        print(\"3. \ud83d\udd27 Refactor\")\n        print(\"4. \ud83d\udcda Documentation\")\n        print(\"5. \ud83e\uddea Testing\")\n        print(\"6. \ud83c\udfa8 UI/UX improvement\")\n        print(\"7. \u26a1 Performance optimization\")\n        print(\"8. \ud83d\udd12 Security enhancement\")\n        print(\"9. \ud83d\udce6 Other\")\n\n        task_type_map = {\n            '1': ('bug', 'Bug Fix'),\n            '2': ('feature', 'Feature'),\n            '3': ('refactor', 'Refactor'),\n            '4': ('docs', 'Documentation'),\n            '5': ('test', 'Testing'),\n            '6': ('ui', 'UI/UX'),\n            '7': ('perf', 'Performance'),\n            '8': ('security', 'Security'),\n            '9': ('other', 'Task')\n        }\n\n        choice = input(\"\\nSelect (1-9): \").strip()\n        task_type, task_label = task_type_map.get(choice, ('other', 'Task'))\n\n        # Get initial description\n        print(f\"\\n\ud83d\udcdd Describe the {task_label.lower()}:\")\n        description = input(\"> \").strip()\n\n        # Intelligent clarification based on task type\n        clarifications = []\n\n        if task_type == 'bug':\n            print(\"\\n\ud83e\udd14 Let me help you clarify this bug fix...\")\n\n            # Error behavior\n            print(\"\\nWhat's the current incorrect behavior?\")\n            current = input(\"> \").strip()\n            if current:\n                clarifications.append(f\"Current behavior: {current}\")\n\n            # Expected behavior\n            print(\"\\nWhat should happen instead?\")\n            expected = input(\"> \").strip()\n            if expected:\n                clarifications.append(f\"Expected behavior: {expected}\")\n\n            # Scope\n            print(\"\\nAre there any edge cases or related areas that might be affected?\")\n            print(\"(Press Enter to skip)\")\n            edge_cases = input(\"> \").strip()\n            if edge_cases:\n                clarifications.append(f\"Consider: {edge_cases}\")\n\n        elif task_type == 'feature':\n            print(\"\\n\ud83e\udd14 Let's make sure we've thought this through...\")\n\n            # User value\n            print(\"\\nWho will use this feature and why?\")\n            users = input(\"> \").strip()\n            if users:\n                clarifications.append(f\"Users: {users}\")\n\n            # Success criteria\n            print(\"\\nHow will you know this feature is working correctly?\")\n            print(\"(What's the simplest test case?)\")\n            test_case = input(\"> \").strip()\n            if test_case:\n                clarifications.append(f\"Success criteria: {test_case}\")\n\n            # Non-goals\n            print(\"\\nWhat should this feature NOT do? (helps prevent scope creep)\")\n            print(\"(Press Enter to skip)\")\n            non_goals = input(\"> \").strip()\n            if non_goals:\n                clarifications.append(f\"NOT doing: {non_goals}\")\n\n            # Dependencies\n            print(\"\\nDoes this depend on any existing functionality?\")\n            print(\"(Press Enter if none)\")\n            deps = input(\"> \").strip()\n            if deps:\n                clarifications.append(f\"Depends on: {deps}\")\n\n        elif task_type == 'refactor':\n            print(\"\\n\ud83e\udd14 Let's ensure this refactor has clear goals...\")\n\n            # Problem\n            print(\"\\nWhat specific problem does this refactor solve?\")\n            problem = input(\"> \").strip()\n            if problem:\n                clarifications.append(f\"Problem: {problem}\")\n\n            # Boundaries\n            print(\"\\nWhat code should be touched? What should NOT be changed?\")\n            boundaries = input(\"> \").strip()\n            if boundaries:\n                clarifications.append(f\"Boundaries: {boundaries}\")\n\n            # Verification\n            print(\"\\nHow will you verify nothing broke? (existing tests? manual checks?)\")\n            verify = input(\"> \").strip()\n            if verify:\n                clarifications.append(f\"Verification: {verify}\")\n\n        elif task_type == 'security':\n            print(\"\\n\ud83e\udd14 Security requires careful consideration...\")\n\n            # Threat\n            print(\"\\nWhat specific vulnerability or threat are you addressing?\")\n            threat = input(\"> \").strip()\n            if threat:\n                clarifications.append(f\"Threat: {threat}\")\n\n            # Impact\n            print(\"\\nWhat could happen if this isn't fixed?\")\n            impact = input(\"> \").strip()\n            if impact:\n                clarifications.append(f\"Impact: {impact}\")\n\n        elif task_type == 'perf':\n            print(\"\\n\ud83e\udd14 Let's define performance goals...\")\n\n            # Current performance\n            print(\"\\nWhat's the current performance issue? (slow load? high memory?)\")\n            current_perf = input(\"> \").strip()\n            if current_perf:\n                clarifications.append(f\"Current issue: {current_perf}\")\n\n            # Target\n            print(\"\\nWhat's your performance target? (2x faster? under 100ms?)\")\n            target = input(\"> \").strip()\n            if target:\n                clarifications.append(f\"Target: {target}\")\n\n        # Generate smart requirements based on type and clarifications\n        requirements = []\n\n        if task_type == 'bug':\n            requirements.append(\"Reproduce the bug consistently\")\n            requirements.append(\"Fix the root cause\")\n            requirements.append(\"Add test to prevent regression\")\n            if 'edge cases' in ' '.join(clarifications).lower():\n                requirements.append(\"Handle edge cases\")\n\n        elif task_type == 'feature':\n            requirements.append(\"Implement core functionality\")\n            if test_case:\n                requirements.append(f\"Ensure {test_case}\")\n            requirements.append(\"Add error handling\")\n            requirements.append(\"Write tests\")\n            if users and 'api' not in description.lower():\n                requirements.append(\"Create user interface\")\n\n        elif task_type == 'refactor':\n            requirements.append(\"Identify code to refactor\")\n            requirements.append(\"Refactor without changing behavior\")\n            requirements.append(\"Ensure all tests pass\")\n            requirements.append(\"Update documentation if needed\")\n\n        elif task_type == 'security':\n            requirements.append(\"Identify vulnerable code\")\n            requirements.append(\"Implement secure solution\")\n            requirements.append(\"Add security tests\")\n            requirements.append(\"Document security considerations\")\n\n        elif task_type == 'perf':\n            requirements.append(\"Profile current performance\")\n            requirements.append(\"Implement optimization\")\n            requirements.append(\"Measure improvement\")\n            requirements.append(\"Ensure no functionality regression\")\n\n        else:\n            # Generic requirements\n            requirements.append(\"Implement main functionality\")\n            requirements.append(\"Handle errors gracefully\")\n            requirements.append(\"Add appropriate tests\")\n\n        # Show generated task\n        print(\"\\n\ud83d\udccb Based on our discussion, here's your task structure:\")\n        print(f\"\\nTask: [{task_label}] {description}\")\n\n        if clarifications:\n            print(\"\\nClarifications:\")\n            for c in clarifications:\n                print(f\"  \u2022 {c}\")\n\n        print(\"\\nGenerated Requirements:\")\n        for i, req in enumerate(requirements, 1):\n            print(f\"  {i}. {req}\")\n\n        # Allow requirement editing\n        print(\"\\n\u270f\ufe0f  Would you like to:\")\n        print(\"1. Use these requirements as-is\")\n        print(\"2. Add more requirements\")\n        print(\"3. Edit requirements\")\n        print(\"4. Start over\")\n\n        edit_choice = input(\"\\nSelect (1-4): \").strip()\n\n        if edit_choice == '2':\n            print(\"\\nAdd requirements (empty line to finish):\")\n            while True:\n                new_req = input(f\"{len(requirements)+1}. \").strip()\n                if not new_req:\n                    break\n                requirements.append(new_req)\n\n        elif edit_choice == '3':\n            print(\"\\nEdit requirements (enter number to edit, 'done' to finish):\")\n            while True:\n                for i, req in enumerate(requirements, 1):\n                    print(f\"  {i}. {req}\")\n                edit_num = input(\"\\nEdit which? \").strip()\n                if edit_num.lower() == 'done':\n                    break\n                try:\n                    idx = int(edit_num) - 1\n                    if 0 <= idx < len(requirements):\n                        new_text = input(f\"New text for #{edit_num}: \").strip()\n                        if new_text:\n                            requirements[idx] = new_text\n                except:\n                    pass\n\n        elif edit_choice == '4':\n            print(\"Starting over...\")\n            return main()\n\n        # Create full task description\n        full_task = f\"[{task_label}] {description}\"\n        if clarifications:\n            full_task += \" (\" + \"; \".join(clarifications) + \")\"\n\n        # Initialize with the refined task\n        print(\"\\n\ud83d\ude80 Initializing task monitor...\")\n        sys.argv = ['task_monitor.py', 'init', full_task] + requirements\n        return main()\n\n    elif command == \"init\":\n        if len(sys.argv) < 4:\n            print(\"Usage: task_monitor.py init '<task>' '<req1>' '<req2>' ...\")\n            return\n\n        monitor.task = sys.argv[2]\n        monitor.requirements = []\n\n        # Add requirements with smart priority\n        for i, desc in enumerate(sys.argv[3:], 1):\n            priority = 1 if i <= 2 else (2 if i <= 4 else 3)\n            monitor.requirements.append(\n                TaskRequirement(id=str(i), description=desc, priority=priority)\n            )\n\n        monitor.save_config()\n\n        # Create hooks configuration for Claude Code settings\n        hooks_config = {\n            \"hooks\": {\n                \"Stop\": [\n                    {\n                        \"hooks\": [\n                            {\n                                \"type\": \"command\",\n                                \"command\": f\"python {os.path.abspath(__file__)} hook Stop\"\n                            }\n                        ]\n                    }\n                ]\n            }\n        }\n\n        # Update .claude/settings.local.json with hooks\n        os.makedirs('.claude', exist_ok=True)\n        settings_file = '.claude/settings.local.json'\n        if os.path.exists(settings_file):\n            with open(settings_file, 'r') as f:\n                settings = json.load(f)\n        else:\n            settings = {}\n        \n        settings.update(hooks_config)\n        \n        with open(settings_file, 'w') as f:\n            json.dump(settings, f, indent=2)\n\n        print(f\"\u2705 Initialized: {monitor.task}\")\n        print(f\"\ud83d\udccb Requirements: {len(monitor.requirements)}\")\n        print(\"\ud83e\ude9d Hooks configured in .claude/settings.local.json\")\n        \n        # Check if .claude-task.json is in .gitignore\n        working_dir = os.environ.get('CLAUDE_WORKING_DIR', '.')\n        gitignore_path = Path(working_dir) / \".gitignore\"\n        if gitignore_path.exists():\n            with open(gitignore_path, 'r') as f:\n                gitignore_content = f.read()\n                if '.claude-task.json' not in gitignore_content:\n                    print(\"\\n\u26a0\ufe0f  Consider adding '.claude-task.json' to your .gitignore file\")\n                    print(\"   This file contains local task state and shouldn't be committed\")\n        \n        print(\"\\nRequirements:\")\n        for requirement in monitor.requirements:\n            print(f\"  - {requirement.description} (Priority {requirement.priority})\")\n\n    elif command == \"status\":\n        if not monitor.task:\n            print(\"No task configured. Run: task_monitor.py init\")\n            return\n\n        progress = monitor._get_progress()\n        print(f\"\\n\ud83d\udccc Task: {monitor.task}\")\n        print(f\"\ud83d\udcca Progress: {progress['percentage']:.0f}% complete\")\n        print(f\"\ud83d\udcc8 Stats: {monitor.stats['commands']} commands, {monitor.stats['deviations']} deviations\")\n        print(f\"\\nRequirements:\")\n\n        for requirement in monitor.requirements:\n            icon = \"\u2705\" if requirement.completed else \"\u23f3\"\n            print(f\"  {icon} {requirement.description} (P{requirement.priority})\")\n\n        if progress['percentage'] < 100:\n            print(f\"\\n\u27a1\ufe0f  Next: {monitor._get_next_action()}\")\n\n    elif command == \"reset\":\n        for requirement in monitor.requirements:\n            requirement.completed = False\n        monitor.stats = {'deviations': 0, 'commands': 0}\n        monitor.save_config()\n        print(\"\u2705 Progress reset\")\n\n    elif command == \"hook\":\n        if len(sys.argv) < 3:\n            return\n\n        hook_type = sys.argv[2]\n\n        # Read context from stdin (Claude Code passes this)\n        try:\n            context = json.loads(sys.stdin.read()) if not sys.stdin.isatty() else {}\n        except:\n            context = {}\n\n        # Handle the hook\n        result = monitor.handle_hook(hook_type, context)\n\n        # Output result for Claude Code\n        print(json.dumps(result))\n\n    elif command == \"slash-command\":\n        # Output slash command configuration for Claude Code\n        slash_config = {\n            \"commands\": {\n                \"/task\": {\n                    \"description\": \"Manage task alignment and focus\",\n                    \"subcommands\": {\n                        \"start\": {\n                            \"description\": \"Start a new task with guided setup\",\n                            \"command\": f\"python {os.path.abspath(__file__)} start\"\n                        },\n                        \"status\": {\n                            \"description\": \"Check current task progress\",\n                            \"command\": f\"python {os.path.abspath(__file__)} status\"\n                        },\n                        \"next\": {\n                            \"description\": \"Show next priority action\",\n                            \"command\": f\"python {os.path.abspath(__file__)} next\"\n                        },\n                        \"complete\": {\n                            \"description\": \"Mark current requirement as complete\",\n                            \"command\": f\"python {os.path.abspath(__file__)} complete\"\n                        },\n                        \"focus\": {\n                            \"description\": \"Get reminder of current focus area\",\n                            \"command\": f\"python {os.path.abspath(__file__)} focus\"\n                        }\n                    }\n                },\n                \"/focus\": {\n                    \"description\": \"Quick reminder of what to work on next\",\n                    \"command\": f\"python {os.path.abspath(__file__)} focus\"\n                }\n            }\n        }\n        print(json.dumps(slash_config, indent=2))\n\n    elif command == \"next\":\n        # Quick command to show next action\n        if not monitor.task:\n            print(\"No task configured. Run: /task start\")\n            return\n\n        progress = monitor._get_progress()\n        current = monitor._get_current_requirement()\n\n        if current != \"All complete\":\n            print(f\"\ud83d\udccc Next: {current}\")\n            print(f\"\ud83d\udcca Progress: {progress['percentage']:.0f}% ({progress['completed']}/{progress['total']})\")\n        else:\n            print(\"\u2705 All requirements complete!\")\n\n    elif command == \"focus\":\n        # Quick focus reminder\n        if not monitor.task:\n            print(\"No task configured. Run: /task start\")\n            return\n\n        print(f\"\ud83c\udfaf Task: {monitor.task}\")\n        print(f\"\ud83d\udccc Focus on: {monitor._get_current_requirement()}\")\n\n        # Show any active warnings\n        if monitor.stats['deviations'] > 0:\n            print(f\"\u26a0\ufe0f  {monitor.stats['deviations']} deviations detected this session\")\n\n    elif command == \"complete\":\n        # Mark current requirement as complete\n        if not monitor.task:\n            print(\"No task configured.\")\n            return\n\n        for requirement in monitor.requirements:\n            if not requirement.completed:\n                requirement.completed = True\n                monitor.save_config()\n                print(f\"\u2705 Completed: {requirement.description}\")\n\n                # Show next\n                progress = monitor._get_progress()\n                if progress['percentage'] < 100:\n                    print(f\"\\n\ud83d\udcca Progress: {progress['percentage']:.0f}% ({progress['completed']}/{progress['total']})\")\n                    print(f\"\ud83d\udccc Next: {monitor._get_current_requirement()}\")\n                else:\n                    print(\"\\n\ud83c\udf89 All requirements complete!\")\n                break\n\nif __name__ == \"__main__\":\n    main()",
        "numLines": 661,
        "startLine": 1,
        "totalLines": 661
      }
    }
  }
]